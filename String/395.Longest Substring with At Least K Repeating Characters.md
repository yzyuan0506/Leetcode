### Method 1: 递归 + two pointers
```
class Solution {
public:
    int longestSubstring(string s, int k) {
        if (s.length() == 0) return 0;
        vector<int> chars(26, 0);
        for (char ch : s) {
            chars[ch - 'a'] += 1;
        }
        
        bool ifFullString = true; // 当前string的字母是否全部出现至少k次
        for (char ch : s) {
            if (chars[ch - 'a'] < k) {
                ifFullString = false;
                break;
            }
        }
        
        // 当前string全部字母都至少出现k次，直接 return
        if (ifFullString) return s.length();
        
        int start = 0, end = 0, res = 0;
        while (end < s.length()) {  // two pointers, 分割字符串
            char ch = s[end];
            if (chars[ch - 'a'] < k) {   // end 遇到出现次数小于k 的字母，删掉，分割字符串
                res = max(res, longestSubstring(s.substr(start, end - start), k));
                start = end + 1;    // 分割后移动start 到 end下一位
            }
            end++;
        }
        
        res = max(res, longestSubstring(s.substr(start), k)); // 处理最后剩下的一段字符串
        return res;
    }
};
```

先预先处理看那些字母出现少于 k 次，
然后我们把它们从字符串”删掉“，分割字符串后再递归检查字符串是否合法

时间复杂度： O(n)
递归每层是 O(n)，最多删除26个字母，递归26层，O(26*n) = O(n)